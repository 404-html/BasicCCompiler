
<def>							::= 	<functionList>;
<functionList>					::=		{ <functionDef> } ;
<functionDef>					::=		<returnType>		"<code>"
																std::string sReturnType = GrammerUtils::m_pPrevToken.getText();
															"</code>"
										TK_FUNCTIONCALL		"<code>"
																std::string sFunctionName = GrammerUtils::m_pPrevToken.getText();
																updateBlockString(sFunctionName);
																
																Tree* pFunctionDefNode = makeLeaf(ASTNodeType::ASTNode_FUNCTIONDEF, sFunctionName.c_str());
																Tree* pReturnTypeNode = makeLeaf(ASTNodeType::ASTNode_FUNCTIONRETURNTYPE, sReturnType.c_str());
																Tree* pArgListNode = makeLeaf(ASTNodeType::ASTNode_FUNCTIONARGLIST, "");
																{
																	pReturnTypeNode->m_pParentNode = pFunctionDefNode;
																	pArgListNode->m_pParentNode = pFunctionDefNode;
																	
																	m_pASTCurrentNode->addChild(pFunctionDefNode);
																	
																	pFunctionDefNode->m_pLeftNode = pReturnTypeNode;
																	pFunctionDefNode->m_pRightNode = pArgListNode;
																}
															"</code>"
										'('					"<code>"
																Tree* pTemp = nullptr;
																{
																	pTemp = m_pASTCurrentNode; // Save Root Node temporarily
																	m_pASTCurrentNode = pArgListNode;
																}
															"</code>"
										[ <functionArgumentDefList>	]	"<code>"
																			m_pASTCurrentNode = pTemp;
																		"</code>"
																
										')'
										'{'					"<code>"
																pTemp = m_pASTCurrentNode; // Save Root Node temporarily
																m_pASTCurrentNode = pFunctionDefNode;
																
																Tree* pFuncStartNode = makeLeaf(ASTNodeType::ASTNode_FUNCTIONSTART, "");
																m_pASTCurrentNode->addChild(pFuncStartNode);
															"</code>"
										<stmt_list>
										'}'					"<code>"
																removeLastFromBlockString();
																
																Tree* pFuncEndNode = makeLeaf(ASTNodeType::ASTNode_FUNCTIONEND, "");
																m_pASTCurrentNode->addChild(pFuncEndNode);

																m_pASTCurrentNode = pTemp;
															"</code>"
										;

<returnType>					::=		(	"int"
											|
											"void"
										);
<functionArgumentDefList>		::=		{ <functionArgumentDefListMore> };
<functionArgumentDefListMore>	::=		(	<primitiveTypeInt>
											[',']
											|
											<primitiveTypeString>
											[',']
										);
<primitiveTypeInt>				::= 	"int" 
										TK_IDENTIFIER		"<code>"
																std::string sArgName = GrammerUtils::m_pPrevToken.getText();
																std::string sFullyQualifiedArgName;
																sFullyQualifiedArgName.append(getBlockString());
																sFullyQualifiedArgName.append(sArgName);

																Tree* pPrimIntNode = makeLeaf(ASTNodeType::ASTNode_PRIMITIVETYPEINT, sFullyQualifiedArgName.c_str());
																{
																	pPrimIntNode->m_sAdditionalInfo.append(sArgName);
																	
																	m_pASTCurrentNode->addChild(pPrimIntNode);
																	m_pASTCurrentNode->m_sAdditionalInfo.append("I");
																}
															"</code>"
										;
<primitiveTypeString>			::= 	"string" 
										TK_IDENTIFIER		"<code>"
																std::string sArgName = GrammerUtils::m_pPrevToken.getText();
																std::string sFullyQualifiedArgName;
																sFullyQualifiedArgName.append(getBlockString());
																sFullyQualifiedArgName.append(sArgName);
																
																Tree* pPrimStringNode = makeLeaf(ASTNodeType::ASTNode_PRIMITIVETYPESTRING, sFullyQualifiedArgName.c_str());
																{
																	pPrimStringNode->m_sAdditionalInfo.append(sArgName);
																	
																	m_pASTCurrentNode->addChild(pPrimStringNode);
																	m_pASTCurrentNode->m_sAdditionalInfo.append("S");
																}
															"</code>"
										;
										
										
<stmt_list> 					::=		{ <stmt> [';'] };

<stmt>      					::=   	( 	<functionCall> 
											|
											<prePostFixedIncrDecr>
											| 
											<assignmentRHS> 
											| 
											<assignmentNewVariable> 
											| 
											<ifelse> 
											| 
											<_while> 
											|
											<forStatement>											
											|
											<print> 
											| 
											<putc> 
											| 
											<bracesstmtlist> 
											| 
											<returnStatement>
										);
										
<prePostFixedIncrDecr>			::=		(	<preFixIncrDecr>
											|
											<postFixIncrDecr>
										);

<preFixIncrDecr>				::= 	(	TK_PREFIXDECR	"<code>"
																std::string sVariableName = GrammerUtils::m_pPrevToken.m_sText;
																std::string sFullyQualifiedVariableName = getFullyQualifiedNameForVariable(m_pASTCurrentNode, sVariableName);
																Tree* pPreDecrNode = makeLeaf(ASTNodeType::ASTNode_PREDECR, sFullyQualifiedVariableName.c_str());
																{
																	m_pASTCurrentNode->addChild(pPreDecrNode);
																}
															"</code>"
											|
											TK_PREFIXINCR	"<code>"
																std::string sVariableName = GrammerUtils::m_pPrevToken.m_sText;
																std::string sFullyQualifiedVariableName = getFullyQualifiedNameForVariable(m_pASTCurrentNode, sVariableName);
																Tree* pPreDecrNode = makeLeaf(ASTNodeType::ASTNode_PREINCR, sFullyQualifiedVariableName.c_str());
																{
																	m_pASTCurrentNode->addChild(pPreDecrNode);
																}
															"</code>"
										);

<postFixIncrDecr>				::= 	(	TK_POSTFIXDECR	"<code>"
																std::string sVariableName = GrammerUtils::m_pPrevToken.m_sText;
																std::string sFullyQualifiedVariableName = getFullyQualifiedNameForVariable(m_pASTCurrentNode, sVariableName);
																Tree* pPreDecrNode = makeLeaf(ASTNodeType::ASTNode_POSTDECR, sFullyQualifiedVariableName.c_str());
																{
																	m_pASTCurrentNode->addChild(pPreDecrNode);
																}
															"</code>"
											|
											TK_POSTFIXINCR	"<code>"
																std::string sVariableName = GrammerUtils::m_pPrevToken.m_sText;
																std::string sFullyQualifiedVariableName = getFullyQualifiedNameForVariable(m_pASTCurrentNode, sVariableName);
																Tree* pPreDecrNode = makeLeaf(ASTNodeType::ASTNode_POSTINCR, sFullyQualifiedVariableName.c_str());
																{
																	m_pASTCurrentNode->addChild(pPreDecrNode);
																}
															"</code>"
										);

<returnStatement>				::=		"return"
													"<code>"
														updateBlockString("return");
														
														Tree* pReturnStmtNode = makeLeaf(ASTNodeType::ASTNode_RETURNSTMT, "return");
														{
															pReturnStmtNode->m_pParentNode = m_pASTCurrentNode;
														}
														
														Tree* pTemp = nullptr;
														Tree* pExpressionLeftLeaf = makeLeaf(ASTNodeType::ASTNode_EXPRESSION, "");
														{
															pExpressionLeftLeaf->m_pParentNode = pReturnStmtNode;
															
															pTemp = m_pASTCurrentNode;
															m_pASTCurrentNode = pExpressionLeftLeaf;
														}
													"</code>"
										<expr>		"<code>"
														removeLastFromBlockString();
														
														m_pASTCurrentNode = createPostFixExpr(m_pASTCurrentNode);
														pReturnStmtNode->addChild(pExpressionLeftLeaf);
														
														m_pASTCurrentNode = pTemp;
														m_pASTCurrentNode->addChild(pReturnStmtNode);
													"</code>"
										;

<functionCall>					::=		TK_FUNCTIONCALL
										"<code>"
											std::string sIdentifier = GrammerUtils::m_pPrevToken.getText();
										"</code>"
										'('				"<code>"
															Tree* pFunctionCallNode = makeLeaf(ASTNodeType::ASTNode_FUNCTIONCALL, sIdentifier.c_str());
															Tree* pTemp = nullptr;
															{
																m_pASTCurrentNode->addChild(pFunctionCallNode);
																
																pTemp = m_pASTCurrentNode;
																m_pASTCurrentNode = pFunctionCallNode;
															}
														"</code>"
										[ <functionArgumentList> ]
										')'
														"<code>"
															Tree* pFuncCallEndNode = makeLeaf(ASTNodeType::ASTNode_FUNCTIONCALLEND, sIdentifier.c_str());
															m_pASTCurrentNode->addChild(pFuncCallEndNode);
															
															m_pASTCurrentNode = pTemp;
														"</code>"
										;
										
<functionArgumentList>			::=		{ <functionArgumentItem> } ;
<functionArgumentItem>			::=		( 	TK_STRING  	"<code>"
															Tree* pStringNode = makeLeaf(ASTNodeType::ASTNode_STRING, GrammerUtils::m_pPrevToken.getText());
															{
																m_pASTCurrentNode->addChild(pStringNode);
																m_pASTCurrentNode->m_sAdditionalInfo.append("S");
															}
														"</code>"
											[',']
											|
											<expr> 		"<code>"
															Tree* pExpressionLeftLeaf = createPostFixExpr();
															{
																m_pASTCurrentNode->addChild(pExpressionLeftLeaf);
																pExpressionLeftLeaf->m_pParentNode = m_pASTCurrentNode;
																
																m_pASTCurrentNode->m_sAdditionalInfo.append("I");
															}
														"</code>"
											[',']
											|
											TK_INTEGER	"<code>"
																Tree* pIntegerNode = makeLeaf(ASTNodeType::ASTNode_INTEGER, GrammerUtils::m_pPrevToken.getText());
																{
																	m_pASTCurrentNode->addChild(pIntegerNode);
																	m_pASTCurrentNode->m_sAdditionalInfo.append("C");
																}
															"</code>"
											|
											TK_CHARACTER	"<code>"
																Tree* pCharacterNode = makeLeaf(ASTNodeType::ASTNode_CHARACTER, GrammerUtils::m_pPrevToken.getText());
																{
																	m_pASTCurrentNode->addChild(pCharacterNode);
																	m_pASTCurrentNode->m_sAdditionalInfo.append("I");
																}
															"</code>"
										) ;

<ifelse>						::= 	<_if>;
<_if>							::=		"if"
										'('				"<code>"
															updateBlockString("if");

															Tree* pIfNode = makeLeaf(ASTNodeType::ASTNode_IF, "if");
															{
																pIfNode->m_pParentNode = m_pASTCurrentNode;
															}

															Tree* pTemp = nullptr;
															Tree* pExpressionLeftLeaf = makeLeaf(ASTNodeType::ASTNode_EXPRESSION, "");
															{
																pIfNode->m_pLeftNode = pExpressionLeftLeaf;
																pExpressionLeftLeaf->m_pParentNode = pIfNode;
																
																pTemp = m_pASTCurrentNode;
																m_pASTCurrentNode = pExpressionLeftLeaf;
															}
														"</code>"
										<expr>			"<code>"
															m_pASTCurrentNode = createPostFixExpr(m_pASTCurrentNode);
															m_pASTCurrentNode = pIfNode;
														"</code>"
										')'
										['{']
										<stmt_list>
										['}'] 			"<code>"
															removeLastFromBlockString();
														"</code>"
										[ <_else> ]		"<code>"
															m_pASTCurrentNode = pTemp;
															m_pASTCurrentNode->addChild(pIfNode);
														"</code>"
										;
										
<_else>							::=		"else" 			"<code>"
															updateBlockString("else");
															
															Tree* pElseNode = makeLeaf(ASTNodeType::ASTNode_ELSE, GrammerUtils::m_pPrevToken.getText());
															Tree* pIfNode = nullptr;
															{	
																pIfNode = m_pASTCurrentNode;
																pElseNode->m_pParentNode = pIfNode->m_pParentNode;
																
																m_pASTCurrentNode = pElseNode;
															}
														"</code>"
										['{']
										<stmt_list>
										['}'] 			"<code>"
															removeLastFromBlockString();
															
															pIfNode->m_pRightNode = pElseNode;
															{
																m_pASTCurrentNode = pIfNode;
															}
														"</code>"
										;

<_while>						::= 	"while"
										'('				"<code>"
															updateBlockString("while");
															
															Tree* pWhileNode = makeLeaf(ASTNodeType::ASTNode_WHILE, "while");
															{
																pWhileNode->m_pParentNode = m_pASTCurrentNode;
															}
															
															Tree* pTemp = nullptr;
															Tree* pExpressionLeftLeaf = makeLeaf(ASTNodeType::ASTNode_EXPRESSION, "");
															{
																pWhileNode->m_pLeftNode = pExpressionLeftLeaf;
																pExpressionLeftLeaf->m_pParentNode = pWhileNode;
																
																pTemp = m_pASTCurrentNode;
																m_pASTCurrentNode = pExpressionLeftLeaf;
															}
														"</code>"
										<expr>			"<code>"
															m_pASTCurrentNode = createPostFixExpr(m_pASTCurrentNode);
															m_pASTCurrentNode = pWhileNode;
														"</code>"
										')'
										['{']
										<stmt_list> 
										['}'] 			"<code>"
															removeLastFromBlockString();
															
															m_pASTCurrentNode = pTemp;
															m_pASTCurrentNode->addChild(pWhileNode);
														"</code>"
										;

<forStatement>					::= 	"for"
										'('				"<code>"
															updateBlockString("for");
															
															////////////////////////////////
															// for ( init-expression ; cond-expression ; loop-expression ) 
															// {
															//		statement;
															// }
															////////////////////////////////
															// init-expression;
															// while(cond-expression)
															// {
															//   	...
															//		...
															//		loop-expression
															// }
															////////////////////////////////
															// A "for" loop is an extended "while" loop where:
															// 		- The "init-expression" list forms a set of statements before the "while" block.
															//		- The "cond-expression" forms the "cond-expression" of the "while" block.
															//		- And the "loop-expression" are the set of statements that are at the tail-end of the "while" block.
															////////////////////////////////
														"</code>"
										[ <oneOrMoreInitExprs> ]
										';'				"<code>"
															Tree* pWhileNode = makeLeaf(ASTNodeType::ASTNode_WHILE, "while");
															{
																pWhileNode->m_pParentNode = m_pASTCurrentNode;
															}

															Tree* pTemp = nullptr;
															Tree* pExpressionLeftLeaf = makeLeaf(ASTNodeType::ASTNode_EXPRESSION, "");
															{
																pWhileNode->m_pLeftNode = pExpressionLeftLeaf;
																pExpressionLeftLeaf->m_pParentNode = pWhileNode;
																
																pTemp = m_pASTCurrentNode;
																m_pASTCurrentNode = pExpressionLeftLeaf;
															}
														"</code>"
										<expr>			"<code>"
															m_pASTCurrentNode = createPostFixExpr(m_pASTCurrentNode);
														"</code>"
										';'				"<code>"
															Tree* pFor_LoopExpressionsLeaf = makeLeaf(ASTNodeType::ASTNode_INVALID, "");
															{
																pFor_LoopExpressionsLeaf->m_pParentNode = pWhileNode;
																m_pASTCurrentNode = pFor_LoopExpressionsLeaf;
															}
														"</code>"
										[ <oneOrMoreLoopExprs> ]
										')'				"<code>"
															m_pASTCurrentNode = pWhileNode;
														"</code>"
										[ '{' ]
										<stmt_list>
										[ '}' ]			"<code>"
															removeLastFromBlockString();
															
															for(Tree* pLoopExpr : pFor_LoopExpressionsLeaf->m_vStatements)
															{
																pWhileNode->addChild(pLoopExpr);
															}

															m_pASTCurrentNode = pTemp;
															m_pASTCurrentNode->addChild(pWhileNode);
														"</code>"
										;
										
<oneOrMoreInitExprs>			::= 	<initExpr> { ',' <initExpr> };

<initExpr>						::=		(	<newInt>
											|
											<assignmentRHS>
										);

<oneOrMoreLoopExprs>			::=		<loopExpr> { ',' <loopExpr> };
<loopExpr>						::=		( 	<preFixIncrDecr>	"<code>"
																	// If it's a pre-fixed expression, we shoule be adding it to the beginning of the whileNode list.
																	// i.e 1st removing it from the 'moreLoop' expression list
																	// & then adding it at the start of the 'whileNode' list.
																	
																	Tree* pWhileNode = m_pASTCurrentNode->m_pParentNode;
																	Tree* pPreFixNode = m_pASTCurrentNode->getLastStatement();
																	{
																		pPreFixNode->removeFromParent();
																		pWhileNode->insertAt(0, pPreFixNode);
																	}
																"</code>"
											|
											<postFixIncrDecr>
											|
											<assignmentRHS>
										);

<print>							::= 	"print" 
										'(' 			"<code>"
															Tree* pPrintNode = makeLeaf(ASTNodeType::ASTNode_PRINT, GrammerUtils::m_pPrevToken.getText());
															Tree* pTemp = nullptr;
															{
																m_pASTCurrentNode->addChild(pPrintNode);
																
																pTemp = m_pASTCurrentNode;
																m_pASTCurrentNode = pPrintNode;
															}
														"</code>"
										<print_list> 
										')' 
														"<code>"
															m_pASTCurrentNode = pTemp;
														"</code>"
										;
										
<print_list>					::= 	{ <print_list_0> } ;
<print_list_0>					::= 	( 	TK_STRING  	"<code>"
															Tree* pStringNode = makeLeaf(ASTNodeType::ASTNode_STRING, GrammerUtils::m_pPrevToken.getText());
															{
																m_pASTCurrentNode->addChild(pStringNode);
															}
														"</code>"
											[',']
											|
											<expr> 		"<code>"
															Tree* pExpressionLeftLeaf = createPostFixExpr();
															{
																m_pASTCurrentNode->addChild(pExpressionLeftLeaf);
																pExpressionLeftLeaf->m_pParentNode = m_pASTCurrentNode;
															}
														"</code>"
											[',']
											|
											TK_CHARACTER	"<code>"
																Tree* pCharacterNode = makeLeaf(ASTNodeType::ASTNode_CHARACTER, GrammerUtils::m_pPrevToken.getText());
																{
																	m_pASTCurrentNode->addChild(pCharacterNode);
																}
															"</code>"
										) ;

<putc>							::=		"putc" 				"<code>"
																Tree* pPutCNode = makeLeaf(ASTNodeType::ASTNode_PUTC, GrammerUtils::m_pPrevToken.getText());
																Tree* pTemp = nullptr;
																{
																	m_pASTCurrentNode->addChild(pPutCNode);

																	pTemp = m_pASTCurrentNode;
																	m_pASTCurrentNode = pPutCNode;
																}
															"</code>"
										'(' 
										<putcList>
										')' 
															"<code>"
																m_pASTCurrentNode = pTemp;
															"</code>"
										;
										
<putcList>						::=		( 	TK_IDENTIFIER 	"<code>"
																std::string sVariableName = GrammerUtils::m_pPrevToken.getText();
																std::string sFullyQualifiedVariableName = getFullyQualifiedNameForVariable(m_pASTCurrentNode, sVariableName);
																assert(!sFullyQualifiedVariableName.empty());

																Tree* pIdentifierNode = makeLeaf(ASTNodeType::ASTNode_IDENTIFIER, sFullyQualifiedVariableName.c_str());
																m_pASTCurrentNode->addChild(pIdentifierNode);
															"</code>"
											|
											TK_INTEGER		"<code>"
																Tree* pIntegerNode = makeLeaf(ASTNodeType::ASTNode_INTEGER, GrammerUtils::m_pPrevToken.getText());
																m_pASTCurrentNode->addChild(pIntegerNode);
															"</code>"
											|
											TK_CHARACTER 	"<code>"
																Tree* pCharacterNode = makeLeaf(ASTNodeType::ASTNode_CHARACTER, GrammerUtils::m_pPrevToken.getText());
																m_pASTCurrentNode->addChild(pCharacterNode);
															"</code>"
										);

<bracesstmtlist>				::= 	'{' 				"<code>"
																updateBlockString("{");
															"</code>"
										<stmt_list> 
										'}'					"<code>"
																removeLastFromBlockString();
															"</code>"
										;

<assignmentNewVariable>			::=		( <newInt> | <newString> );

<newInt>						::= 	"int" 
										TK_IDENTIFIER 		"<code>"
																std::string sVariableName = GrammerUtils::m_pPrevToken.getText();
																std::string sFullyQualifiedVariableName;
																sFullyQualifiedVariableName.append(getBlockString());
																sFullyQualifiedVariableName.append(sVariableName);
															"</code>"
										'='					"<code>"
																Tree* pPrimIntNode = makeLeaf(ASTNodeType::ASTNode_PRIMITIVETYPEINT, sFullyQualifiedVariableName.c_str());
																Tree* pTemp = nullptr;
																{
																	pPrimIntNode->m_sAdditionalInfo.append(sVariableName);
																	pPrimIntNode->m_pParentNode = m_pASTCurrentNode;
																}
																
																Tree* pExpressionLeftLeaf = makeLeaf(ASTNodeType::ASTNode_EXPRESSION, "");
																{
																	pPrimIntNode->m_pLeftNode = pExpressionLeftLeaf;
																	pExpressionLeftLeaf->m_pParentNode = pPrimIntNode;
																	
																	pTemp = m_pASTCurrentNode;
																	m_pASTCurrentNode = pExpressionLeftLeaf;
																}

															"</code>"
										<expr>				"<code>"
																m_pASTCurrentNode = createPostFixExpr(m_pASTCurrentNode);
															
																m_pASTCurrentNode = pTemp;
																m_pASTCurrentNode->addChild(pPrimIntNode);
															"</code>"
										;
										
<newString>						::= 	"string" 
										TK_IDENTIFIER 		"<code>"
																std::string sVariableName = GrammerUtils::m_pPrevToken.getText();
																std::string sFullyQualifiedVariableName;
																sFullyQualifiedVariableName.append(getBlockString());
																sFullyQualifiedVariableName.append(sVariableName);
															"</code>"
										'='					"<code>" 
																Tree* pPrimStringNode = makeLeaf(ASTNodeType::ASTNode_PRIMITIVETYPESTRING, sFullyQualifiedVariableName.c_str());
																{
																	pPrimStringNode->m_sAdditionalInfo.append(sVariableName);
																}
															"</code>"
										<expr>				"<code>"
																Tree* pExpressionLeftLeaf = createPostFixExpr();
																{
																	pPrimStringNode->m_pLeftNode = pExpressionLeftLeaf;
																	pExpressionLeftLeaf->m_pParentNode = m_pASTCurrentNode;
																}
															"</code>"
															"<code>"
																m_pASTCurrentNode->addChild(pPrimStringNode);
															"</code>"
										;

<assignmentRHS>					::=  	TK_IDENTIFIER
										"<code>"
											std::string sVariableName = GrammerUtils::m_pPrevToken.getText();
										"</code>"
										'='				"<code>"
															std::string sFullyQualifiedVariableName = getFullyQualifiedNameForVariable(m_pASTCurrentNode, sVariableName);
															assert(!sFullyQualifiedVariableName.empty());

															Tree* pAssignmentNode = makeLeaf(ASTNodeType::ASTNode_ASSIGN, sFullyQualifiedVariableName.c_str());
															Tree* pTemp = nullptr;
															{
																pAssignmentNode->m_pParentNode = m_pASTCurrentNode;
															}
															
															Tree* pIdentifierLeaf = makeLeaf(ASTNodeType::ASTNode_IDENTIFIER, sFullyQualifiedVariableName.c_str());
															{
																pIdentifierLeaf->m_sAdditionalInfo = sVariableName;
																pAssignmentNode->m_pRightNode = pIdentifierLeaf;
															}
															
															Tree* pExpressionLeftLeaf = makeLeaf(ASTNodeType::ASTNode_EXPRESSION, "");
															{
																pAssignmentNode->m_pLeftNode = pExpressionLeftLeaf;
																pExpressionLeftLeaf->m_pParentNode = pAssignmentNode;
																
																pTemp = m_pASTCurrentNode;
																m_pASTCurrentNode = pExpressionLeftLeaf;
															}
														"</code>"
										<expr>
														"<code>"
															m_pASTCurrentNode = createPostFixExpr(m_pASTCurrentNode);
															
															m_pASTCurrentNode = pTemp;
															m_pASTCurrentNode->addChild(pAssignmentNode);
														"</code>"
										;
																														
<expr>                			::=		<and_expr> { <logicalor_expr> } ;
										
<logicalor_expr>				::=		"||" 		"<code>" 
														checkOpPrecedenceAndPush("||");
													"</code>"
										<and_expr> ;
		
<and_expr>            			::=   	<equality_expr> { <logicaland_expr> } ;
<logicaland_expr>				::= 	"&&" 		"<code>" 
														checkOpPrecedenceAndPush("&&");
													"</code>"
										<equality_expr> ;
		
<equality_expr>       			::=   	<relational_expr> [ <equality_expr_optional> ] ;
<equality_expr_optional>		::=		<equality> <relational_expr> ;
<equality>						::= 	(	"==" 	"<code>" 
														checkOpPrecedenceAndPush("==");
													"</code>"
											| 
											"!="	"<code>" 
														checkOpPrecedenceAndPush("!=");
													"</code>"
										) ;
		
<relational_expr>     			::=   	<addition_expr> [ <relational_expr_optional> ] ;
<relational_expr_optional>		::= 	<relational> <addition_expr> ;
<relational>					::= 	(	'<' 	"<code>" 
														checkOpPrecedenceAndPush("<");
													"</code>"
											| 
											"<=" 	"<code>" 
														checkOpPrecedenceAndPush("<=");
													"</code>"
											| 
											'>' 	"<code>" 
														checkOpPrecedenceAndPush(">");
													"</code>"
											| 
											">="	"<code>" 
														checkOpPrecedenceAndPush(">=");
													"</code>"
										) ;
	
<addition_expr>       			::=   	<multiplication_expr> { <addition_expr_optional> } ;
<addition_expr_optional>		::=		<add_sub> <multiplication_expr> ;
<add_sub>						::=		(	'+' 	"<code>" 
														checkOpPrecedenceAndPush("+");
													"</code>"
											| 
											'-'		"<code>" 
														checkOpPrecedenceAndPush("-");
													"</code>"
										) ;
	
<multiplication_expr> 			::=   	<primary> { <multiplication_expr_optional> } ;
<multiplication_expr_optional> 	::=   	<mul_div_mod> <primary> ;
<mul_div_mod>					::=		(	'*' 	"<code>" 
														checkOpPrecedenceAndPush("*");
													"</code>"
											| 
											'/' 	"<code>" 
														checkOpPrecedenceAndPush("/");
													"</code>"
											| 
											'%'		"<code>" 
														checkOpPrecedenceAndPush("%");
													"</code>"
										) ;

<primary>             			::=   	<defaults> ;
<defaults>						::= 	( 	<operands> 
											| 
											<unary_expr>
											|
											<paren_expr> 
										) ;
										
<operands>						::=		"<code>"
											std::string sOperand;
										"</code>"
										
										( 	<functionCall>	"<code>"
																// The idea here is to create a temporary variable of the type returned by the function
																// & add it before the expression statement.
																// The temporary variable is then inserted in the expression.
																// Eg:
																// 		int iRet = 10;
																//		iRet = 10 + retFunc(); // where retFunc return type is "int".
																//		This will create a dummy code as follows:
																//			int iRet = 10;
																//			int iRet_retFunc = retFunc;	// This line of code will be inserted by the following piece of code.
																//			iRet = 10 + iRet_retFunc;
																
																Tree* pExpressionNode = m_pASTCurrentNode;
																Tree* pAssignNode = pExpressionNode->m_pParentNode;
																Tree* pBlockNode = pAssignNode->m_pParentNode;
																Tree* pFunctionCallNode = pExpressionNode->getLastStatement();
																{
																	pFunctionCallNode->removeFromParent();
																}
																assert(pFunctionCallNode != nullptr);
																{
																	std::string sFuncName = pFunctionCallNode->m_sText;
																	std::string sFullyQualifiedTempVariableName;
																	sFullyQualifiedTempVariableName.append(pAssignNode->m_sText);
																	sFullyQualifiedTempVariableName.append("_");
																	sFullyQualifiedTempVariableName.append(sFuncName);
																	
																	Tree* pPrimIntNode = makeLeaf(ASTNodeType::ASTNode_PRIMITIVETYPEINT, sFullyQualifiedTempVariableName.c_str());
																	{
																		pPrimIntNode->m_sAdditionalInfo.append(sFullyQualifiedTempVariableName);
																		pBlockNode->addChild(pPrimIntNode);
																	}
																	
																	Tree* pExpressionLeftLeaf = makeLeaf(ASTNodeType::ASTNode_EXPRESSION, "");
																	{
																		pPrimIntNode->m_pLeftNode = pExpressionLeftLeaf;
																		pExpressionLeftLeaf->m_pParentNode = pPrimIntNode;
																		pExpressionLeftLeaf->addChild(pFunctionCallNode);
																	}
																	
																	m_vPostFix.push_back(sFullyQualifiedTempVariableName);
																}
															"</code>"
											|
											<tk_identifier>
											| 
											TK_INTEGER		"<code>"
																sOperand = GrammerUtils::m_pPrevToken.getText();
																m_vPostFix.push_back(sOperand);
															"</code>"
											|
											TK_CHARACTER	"<code>"
																sOperand = GrammerUtils::m_pPrevToken.getText();
																char pStr[255] = {0};
																sprintf_s(pStr, "%d", sOperand.c_str()[0]);

																m_vPostFix.push_back(pStr);
															"</code>"
										) ;
										
<tk_identifier>					::=		(	<preFixIncrDecrInExpr>
											|
											<postFixIncrDecrInExpr>
											|
											TK_IDENTIFIER	"<code>"
																std::string sOperand = GrammerUtils::m_pPrevToken.getText();
																std::string sFullyQualifiedVariableName = getFullyQualifiedNameForVariable(m_pASTCurrentNode, sOperand);
																assert(!sFullyQualifiedVariableName.empty());
																if(!sFullyQualifiedVariableName.empty())
																{
																	sOperand = sFullyQualifiedVariableName;
																}
																
																m_vPostFix.push_back(sOperand);
															"</code>"
										);
										
<unary_expr>					::=		<unary_oper> <expr>;
<unary_oper>					::=		(	'-'				"<code>" 
																checkOpPrecedenceAndPush("NEGATE");
															"</code>"
											| 
											'!'				"<code>" 
																checkOpPrecedenceAndPush("!");
															"</code>"
										);

<preFixIncrDecrInExpr>				::= 	(	TK_PREFIXDECR	"<code>"
																	if(m_pASTCurrentNode->m_pLeftNode == nullptr)
																	{
																		Tree* pPreFixNode = makeLeaf(ASTNodeType::ASTNode_EXPRESSION_PREFIX, "");
																		m_pASTCurrentNode->m_pLeftNode = pPreFixNode;
																	}
	
																	std::string sVariableName = GrammerUtils::m_pPrevToken.m_sText;
																	std::string sFullyQualifiedVariableName = getFullyQualifiedNameForVariable(m_pASTCurrentNode, sVariableName);
																	Tree* pPreDecrNode = makeLeaf(ASTNodeType::ASTNode_PREDECR, sFullyQualifiedVariableName.c_str());
																	{
																		m_pASTCurrentNode->m_pLeftNode->addChild(pPreDecrNode);
																		m_vPostFix.push_back(sFullyQualifiedVariableName);
																	}
																"</code>"
												|
												TK_PREFIXINCR	"<code>"
																	if(m_pASTCurrentNode->m_pLeftNode == nullptr)
																	{
																		Tree* pPreFixNode = makeLeaf(ASTNodeType::ASTNode_EXPRESSION_PREFIX, "");
																		m_pASTCurrentNode->m_pLeftNode = pPreFixNode;
																	}
	
																	std::string sVariableName = GrammerUtils::m_pPrevToken.m_sText;
																	std::string sFullyQualifiedVariableName = getFullyQualifiedNameForVariable(m_pASTCurrentNode, sVariableName);
																	Tree* pPreIncrNode = makeLeaf(ASTNodeType::ASTNode_PREINCR, sFullyQualifiedVariableName.c_str());
																	{
																		m_pASTCurrentNode->m_pLeftNode->addChild(pPreIncrNode);
																		m_vPostFix.push_back(sFullyQualifiedVariableName);
																	}
																"</code>"
										);

<postFixIncrDecrInExpr>				::= 	(	TK_POSTFIXDECR	"<code>"
																	if(m_pASTCurrentNode->m_pRightNode == nullptr)
																	{
																		Tree* pPostFixNode = makeLeaf(ASTNodeType::ASTNode_EXPRESSION_POSTFIX, "");
																		m_pASTCurrentNode->m_pRightNode = pPostFixNode;
																	}
	
																	std::string sVariableName = GrammerUtils::m_pPrevToken.m_sText;
																	std::string sFullyQualifiedVariableName = getFullyQualifiedNameForVariable(m_pASTCurrentNode, sVariableName);
																	Tree* pPostDecrNode = makeLeaf(ASTNodeType::ASTNode_POSTDECR, sFullyQualifiedVariableName.c_str());
																	{
																		m_pASTCurrentNode->m_pRightNode->addChild(pPostDecrNode);
																		m_vPostFix.push_back(sFullyQualifiedVariableName);
																	}
																"</code>"
												|
												TK_POSTFIXINCR	"<code>"
																	if(m_pASTCurrentNode->m_pRightNode == nullptr)
																	{
																		Tree* pPostFixNode = makeLeaf(ASTNodeType::ASTNode_EXPRESSION_POSTFIX, "");
																		m_pASTCurrentNode->m_pRightNode = pPostFixNode;
																	}
	
																	std::string sVariableName = GrammerUtils::m_pPrevToken.m_sText;
																	std::string sFullyQualifiedVariableName = getFullyQualifiedNameForVariable(m_pASTCurrentNode, sVariableName);
																	Tree* pPostIncrNode = makeLeaf(ASTNodeType::ASTNode_POSTINCR, sFullyQualifiedVariableName.c_str());
																	{
																		m_pASTCurrentNode->m_pRightNode->addChild(pPostIncrNode);
																		m_vPostFix.push_back(sFullyQualifiedVariableName);
																	}
															"</code>"
										);
										
<paren_expr>					::=   	'(' 			"<code>"
															checkOpPrecedenceAndPush("(");
														"</code>"
										<expr> 
										')'				"<code>"
															checkOpPrecedenceAndPush(")");
														"</code>"
										;

