#include "TinyCReader.h"
#include "GrammerUtils.h"

#define __START_BLOCK_STRING__(_BLOCKNAME_) \
	updateBlockString(_BLOCKNAME_); \
	startBlockMarker(); \
	
#define __END_CURRENT_BLOCK__ \
	removeLastFromBlockString(); \
	endBlockMarker(); \

TinyCReader::TinyCReader()
{
	GrammerUtils::init();
}

void TinyCReader::read(const char* sFile)
{
	//////////////// THIS PIECE OF CODE WILL REMAIN COMMON FOR ALL //////////////////
	if (GrammerUtils::read(sFile))
	{
		addKeywords();
		GrammerUtils::getNextToken();

		m_pASTRootNode = new Tree();
		{
			m_pASTRootNode->m_eASTNodeType = ASTNodeType::ASTNode_ROOT;
			m_pASTCurrentNode = m_pASTRootNode;
		}

		def();

		GrammerUtils::generateCode(m_pASTRootNode);
	}
	/////////////////////////////////////////////////////////////////////////////////
}

std::string TinyCReader::popOperator()
{
	if(!m_vOperatorStack.empty())
	{
		std::string sTop = m_vOperatorStack.top();
		m_vOperatorStack.pop();
		
		return sTop;
	}
	
	return "";
}

ENUM_OP_PRECEDENCE TinyCReader::opFromString(std::string sOperator)
{
	ENUM_OP_PRECEDENCE eOperator = ENUM_OP_PRECEDENCE::OP_INVALID;

	if (sOperator == "||")
		eOperator = ENUM_OP_PRECEDENCE::OP_LOGICALOR;
	else
	if (sOperator == "&&")
		eOperator = ENUM_OP_PRECEDENCE::OP_LOGICALAND;
	else
	if (sOperator == "|")
		eOperator = ENUM_OP_PRECEDENCE::OP_BITWISEOR;
	else
	if (sOperator == "&")
		eOperator = ENUM_OP_PRECEDENCE::OP_BITWISEAND;
	else
	if (sOperator == "^")
		eOperator = ENUM_OP_PRECEDENCE::OP_BITWISEXOR;
	else
	if (sOperator == "~")
		eOperator = ENUM_OP_PRECEDENCE::OP_BITWISENOT;
	else
	if (sOperator == "<<")
		eOperator = ENUM_OP_PRECEDENCE::OP_BITWISELEFTSHIFT;
	else
	if (sOperator == ">>")
		eOperator = ENUM_OP_PRECEDENCE::OP_BITWISERIGHTSHIFT;
	else
	if (sOperator == "==")
		eOperator = ENUM_OP_PRECEDENCE::OP_EQ;
	else
	if (sOperator == "!=")
		eOperator = ENUM_OP_PRECEDENCE::OP_NEQ;
	else
	if (sOperator == "<")
		eOperator = ENUM_OP_PRECEDENCE::OP_LT;
	else
	if (sOperator == "<=")
		eOperator = ENUM_OP_PRECEDENCE::OP_LTEQ;
	else
	if (sOperator == ">")
		eOperator = ENUM_OP_PRECEDENCE::OP_GT;
	else
	if (sOperator == ">=")
		eOperator = ENUM_OP_PRECEDENCE::OP_GTEQ;
	else
	if (sOperator == "+")
		eOperator = ENUM_OP_PRECEDENCE::OP_ADD;
	else
	if (sOperator == "-")
		eOperator = ENUM_OP_PRECEDENCE::OP_SUB;
	else
	if (sOperator == "*")
		eOperator = ENUM_OP_PRECEDENCE::OP_MUL;
	else
	if (sOperator == "/")
		eOperator = ENUM_OP_PRECEDENCE::OP_DIV;
	else
	if (sOperator == "(")
		eOperator = ENUM_OP_PRECEDENCE::OP_LPAREN;
	else
	if (sOperator == ")")
		eOperator = ENUM_OP_PRECEDENCE::OP_RPAREN;
	else
	if (sOperator == "%%")
		eOperator = ENUM_OP_PRECEDENCE::OP_MOD;
	else
	if (sOperator == "!")
		eOperator = ENUM_OP_PRECEDENCE::OP_NOT;
	else
	if (sOperator == "NEGATE")
		eOperator = ENUM_OP_PRECEDENCE::OP_NEGATE;

	return eOperator;
}

void TinyCReader::checkOpPrecedenceAndPush(std::string sCurrentOperator)
{
	if(m_vOperatorStack.empty()) m_vOperatorStack.push(sCurrentOperator);
	else
	{
		if (sCurrentOperator == ")")
		{
			while (NOT m_vOperatorStack.empty())
			{
				std::string sOp = m_vOperatorStack.top();
				popOperator();

				if (sOp != "(")
				{	
					m_vPostFix.push_back(sOp);
				}
				else
				{
					break;
				}
			}
		}
		else
		{
			if (sCurrentOperator == "(")
			{
				m_vOperatorStack.push(sCurrentOperator);
			}
			else
			{
				int eCurrOp = (int)opFromString(sCurrentOperator);

				std::string sTopOfStack = m_vOperatorStack.top();
				int eTopOfStack = (int)opFromString(sTopOfStack);

				if (eCurrOp > eTopOfStack)
					m_vOperatorStack.push(sCurrentOperator);
				else
				{
					popOperator();
					m_vPostFix.push_back(sTopOfStack);
					m_vOperatorStack.push(sCurrentOperator);
				}
			}
		}
	}
}

Tree* TinyCReader::createPostFixExpr(Tree* pLeaf /* = nullptr*/)
{
	if (!m_vOperatorStack.empty())
	{
		while (!m_vOperatorStack.empty())
		{
			std::string sTop = m_vOperatorStack.top();
			m_vPostFix.push_back(sTop);

			m_vOperatorStack.pop();
		}
	}

	std::string sPostFixExpr = "";
	
	int iSize = m_vPostFix.size();
	for(int i = 1; i <= iSize; i++)
	{
		sPostFixExpr += m_vPostFix[i-1];
		if(i != iSize)
			sPostFixExpr += ", ";
	}

	m_vPostFix.clear();

	if (pLeaf == nullptr)
		pLeaf = makeLeaf(ASTNodeType::ASTNode_EXPRESSION, sPostFixExpr.c_str());
	else
		pLeaf->m_sText = sPostFixExpr;

	return pLeaf;
}

Tree* TinyCReader::makeLeaf(ASTNodeType eASTNodeType, const char* sText)
{
	Tree* pLeaf = new Tree();
	{
		pLeaf->m_eASTNodeType = eASTNodeType;
		pLeaf->m_sText = sText;
	}

	return pLeaf;
}

Tree* TinyCReader::makeNode(ASTNodeType eASTNodeType, Tree* pLeft, Tree* pRight)
{
	Tree* pNode = new Tree();
	{
		pNode->m_eASTNodeType = eASTNodeType;
		pNode->m_pLeftNode = pLeft;
		pNode->m_pRightNode = pRight;
	}

	return pNode;
}

void TinyCReader::updateBlockString(std::string sIdent)
{
	if (NOT sIdent.empty())
	{
		m_sBlockStringList.push_back(sIdent);
	}
}

std::string TinyCReader::getBlockString()
{
	std::string sReturn;
	for (std::string sStr : m_sBlockStringList)
	{
		sReturn.append(sStr);
		sReturn.append("_");
	}

	return sReturn;
}

void TinyCReader::removeLastFromBlockString()
{
	if (m_sBlockStringList.size() > 0)
	{
		m_sBlockStringList.erase(m_sBlockStringList.end()-1);
	}
}

std::string	TinyCReader::getFullyQualifiedNameForVariable(Tree* pNode, std::string sVariable)
{
	std::string sFullyQualifiedName;
	bool bFound = false;

	if(NOT bFound)
	{
		for (Tree* pChild : pNode->m_vStatements)
		{
			if (pChild->m_eASTNodeType == ASTNodeType::ASTNode_TYPE
				|
				pChild->m_eASTNodeType == ASTNodeType::ASTNode_TYPEARRAY
				|
				pChild->m_eASTNodeType == ASTNodeType::ASTNode_TYPESTRUCT
			) {
				if (pChild->m_sAdditionalInfo == sVariable)
				{
					sFullyQualifiedName = pChild->m_sText;
					bFound = true;
					break;
				}
			}
		}
	}

	if (NOT bFound)
	{
		for (Tree* pStaticVar : FunctionInfo::m_vStaticVariables)
		{
			if (pStaticVar->m_sText == sVariable)
			{
				sFullyQualifiedName = pStaticVar->m_sText;
				bFound = true;
				break;
			}
		}
	}

	// Check for 'Member Variables'
	if (NOT bFound)
	{
		Tree* pParentNode = pNode->m_pParentNode;
		if (pParentNode->m_eASTNodeType == ASTNodeType::ASTNode_STRUCTDEF)
		{
			for (Tree* pChildNode : pParentNode->m_vStatements) // Starts with index 0
			{
				if(	pChildNode->m_eASTNodeType == ASTNodeType::ASTNode_TYPE
					||
					pChildNode->m_eASTNodeType == ASTNodeType::ASTNode_TYPEARRAY
				) {
					if (pChildNode->m_sAdditionalInfo == sVariable)
					{
						sFullyQualifiedName = pChildNode->m_sText;
						bFound = true;
						break;
					}
				}
			}
		}
	}

	if (sFullyQualifiedName.empty())
	{
		if (pNode->m_eASTNodeType == ASTNodeType::ASTNode_FUNCTIONDEF)
		{
			sFullyQualifiedName = getFullyQualifiedNameForVariable(pNode->m_pRightNode, sVariable); // Search in the 'Arg list'.
		}
		else
		{
			sFullyQualifiedName = getFullyQualifiedNameForVariable(pNode->m_pParentNode, sVariable);
		}
	}

	return sFullyQualifiedName;
}

void TinyCReader::addType(std::string sType)
{
	GrammerUtils::m_vTypes.push_back(sType);
}

bool TinyCReader::isValidType(std::string sType)
{
	for(std::string sInBuiltType : GrammerUtils::m_vTypes)
	{
		if(sType == sInBuiltType)
		{
			GrammerUtils::m_pPrevToken = GrammerUtils::m_pToken;
			GrammerUtils::getNextToken();

			return true;
		}
	}
	
	return false;
}

void TinyCReader::addStructType(std::string sType)
{
	GrammerUtils::m_vUserDefinedTypes.push_back(sType);
}

bool TinyCReader::isValidStructType(std::string sType)
{
	for(std::string sInBuiltType : GrammerUtils::m_vUserDefinedTypes)
	{
		if(sType == sInBuiltType)
		{
			GrammerUtils::m_pPrevToken = GrammerUtils::m_pToken;
			GrammerUtils::getNextToken();

			return true;
		}
	}
	
	return false;
}

bool TinyCReader::hasNodeOfType(Tree* pNode, ASTNodeType eASTNodeType)
{
	bool bYes = false;
	if(pNode != nullptr)
	{
		for(Tree* pChild : pNode->m_vStatements)
		{
			if(pChild != nullptr)
			{
				if(pChild->m_eASTNodeType == eASTNodeType)
				{
					bYes = true;
					break;
				}
			}
		}
	}
	
	return bYes;
}

void TinyCReader::startBlockMarker()
{
	m_vLocalHeapVarStack.push("{");
}

void TinyCReader::pushLocalHeapVar(std::string sVariableName)
{
	if (NOT sVariableName.empty())
	{
		m_vLocalHeapVarStack.push(sVariableName);
	}
}

void TinyCReader::endBlockMarker()
{
	while (NOT m_vLocalHeapVarStack.empty())
	{
		std::string sLocalHeapVar = m_vLocalHeapVarStack.top();
		m_vLocalHeapVarStack.pop();
		if (sLocalHeapVar == "{")
		{
			break;
		}
		else
		{
			Tree* pFreeASTNode = GrammerUtils::createNodeOfType(ASTNodeType::ASTNode_FREE, sLocalHeapVar.c_str());
			if (pFreeASTNode != nullptr)
			{
				m_pASTCurrentNode->addChild(pFreeASTNode);
			}
		}
	}
}
